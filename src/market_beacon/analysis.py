from typing import Literal

import numpy as np
import pandas as pd
import talib
from loguru import logger
from pydantic import BaseModel, Field

from .api.models import Candle, OrderBook, Trade

# ==============================================================================
# 1. Pydantic Models for Analysis Results
# ==============================================================================


class TradeAnalysis(BaseModel):
    """
    Pydantic model for holding trade analysis results.
    Some fields are only available in 'full' analysis mode.
    """

    total_trades: int | None = Field(None, description="Total number of trades (full mode only)")
    buy_trades: int | None = Field(None, description="Number of buy-side trades (full mode only)")
    sell_trades: int | None = Field(None, description="Number of sell-side trades (full mode only)")
    total_volume: float = Field(..., description="Total volume of all trades in the period")
    buy_volume: float | None = Field(None, description="Volume of buy-side trades (full mode only)")
    sell_volume: float | None = Field(
        None, description="Volume of sell-side trades (full mode only)"
    )
    vwap: float = Field(
        ..., description="Volume-Weighted Average Price (approximated in fast mode)"
    )


class MovingAverageAnalysis(BaseModel):
    """Analysis of various moving averages and their signals."""

    sma_short: float | None = Field(None, description="Simple Moving Average (e.g., 50-period)")
    sma_long: float | None = Field(None, description="Simple Moving Average (e.g., 200-period)")
    ema_short: float | None = Field(None, description="Exponential Moving Average (e.g., 9-period)")
    ema_medium: float | None = Field(
        None, description="Exponential Moving Average (e.g., 21-period)"
    )
    crossover_signal: Literal["Golden Cross", "Death Cross"] | None = Field(
        None, description="Signal generated by short-term MA crossing long-term MA."
    )
    ema_ribbon: dict[str, float | None] = Field(
        default_factory=dict, description="A series of EMAs to form a trend ribbon."
    )


class MACDAnalysis(BaseModel):
    """Analysis of the Moving Average Convergence Divergence."""

    macd_line: float | None = Field(None, description="The MACD line value.")
    signal_line: float | None = Field(None, description="The signal line value.")
    histogram: float | None = Field(None, description="The MACD histogram value (MACD - Signal).")
    momentum: Literal["Strengthening", "Weakening"] | None = Field(
        None, description="Momentum based on the histogram's recent movement."
    )


class ADXAnalysis(BaseModel):
    """Analysis of the Average Directional Index."""

    adx: float | None = Field(None, description="Average Directional Index value.")
    trend_strength: str | None = Field(
        None, description="Interpretation of the ADX value (e.g., 'Strong Trend')."
    )


class IchimokuCloudAnalysis(BaseModel):
    """Analysis of the Ichimoku Cloud indicator."""

    tenkan_sen: float | None = Field(None, description="Conversion Line (Tenkan-sen)")
    kijun_sen: float | None = Field(None, description="Base Line (Kijun-sen)")
    senkou_span_a: float | None = Field(
        None, description="Leading Span A aligned with the current price."
    )
    senkou_span_b: float | None = Field(
        None, description="Leading Span B aligned with the current price."
    )
    chikou_span: float | None = Field(
        None, description="Lagging Span value (close price from 26 periods ago)."
    )
    price_position: Literal["Above Cloud", "Below Cloud", "In Cloud"] | None = Field(
        None, description="Position of the current price relative to the Kumo cloud."
    )
    cloud_color: Literal["Green", "Red"] | None = Field(
        None, description="Color of the current Kumo cloud."
    )
    future_cloud_color: Literal["Green", "Red"] | None = Field(
        None, description="Color of the future Kumo cloud, indicating a potential 'Kumo Twist'."
    )


class ParabolicSARAnalysis(BaseModel):
    """Analysis of the Parabolic Stop and Reverse."""

    psar: float | None = Field(None, description="Parabolic Stop and Reverse value.")
    trend_direction: Literal["Uptrend", "Downtrend"] | None = Field(
        None, description="Indicated trend direction."
    )
    is_reversal: bool = Field(
        False, description="True if a reversal occurred on the latest candle."
    )


class MomentumAnalysis(BaseModel):
    """Analysis of key momentum oscillators."""

    rsi: float | None = Field(None, description="Relative Strength Index (RSI) value.")
    rsi_level: Literal["Overbought", "Oversold", "Neutral"] | None = Field(
        None, description="Interpretation of the RSI level."
    )
    stochastic_k: float | None = Field(None, description="Stochastic Oscillator %K value.")
    stochastic_d: float | None = Field(None, description="Stochastic Oscillator %D (signal) value.")
    stochastic_level: Literal["Overbought", "Oversold", "Neutral"] | None = Field(
        None, description="Interpretation of the Stochastic level."
    )
    williams_r: float | None = Field(None, description="Williams %R value.")
    williams_r_level: Literal["Overbought", "Oversold", "Neutral"] | None = Field(
        None, description="Interpretation of the Williams %R level."
    )


class VolatilityAnalysis(BaseModel):
    """Analysis of market volatility."""

    atr: float | None = Field(None, description="Average True Range (14-period).")
    bollinger_hband: float | None = Field(None, description="Bollinger Bands Upper Band.")
    bollinger_lband: float | None = Field(None, description="Bollinger Bands Lower Band.")
    bollinger_mavg: float | None = Field(None, description="Bollinger Bands Middle Average.")
    bollinger_bandwidth: float | None = Field(None, description="Width of the Bollinger Bands.")
    bollinger_percent_b: float | None = Field(
        None, description="Price position relative to bands, as a percentage."
    )


class VolumeAnalysis(BaseModel):
    """Analysis of volume-based indicators."""

    on_balance_volume: float | None = Field(None, description="On-Balance Volume (OBV).")
    chaikin_money_flow: float | None = Field(None, description="Chaikin Money Flow (CMF).")


class TrendAnalysis(BaseModel):
    """Container for all trend-related indicators."""

    moving_averages: MovingAverageAnalysis
    macd: MACDAnalysis
    adx: ADXAnalysis
    ichimoku_cloud: IchimokuCloudAnalysis
    parabolic_sar: ParabolicSARAnalysis


class TechnicalAnalysis(BaseModel):
    """A composite model for all technical analysis indicators from candlestick data."""

    price_change_percent: float = Field(
        ..., description="Percentage change from first open to last close"
    )
    trend_indicators: TrendAnalysis = Field(
        ..., description="Trend-following indicators like MAs, MACD, etc."
    )
    momentum_indicators: MomentumAnalysis = Field(
        ..., description="Oscillators like RSI and Stochastics."
    )
    volatility_indicators: VolatilityAnalysis = Field(
        ..., description="Indicators measuring market volatility like ATR and Bollinger Bands."
    )
    volume_indicators: VolumeAnalysis = Field(
        ..., description="Indicators based on trade volume like OBV and CMF."
    )


class AnalysisResult(BaseModel):
    """A composite model for all analysis results."""

    symbol: str
    trade_stats: TradeAnalysis
    technical_analysis: TechnicalAnalysis


class OrderBookAnalysis(BaseModel):
    """Pydantic model for holding order book analysis results."""

    best_bid: float = Field(..., description="The highest price a buyer is willing to pay.")
    best_ask: float = Field(..., description="The lowest price a seller is willing to accept.")
    mid_price: float = Field(..., description="The average of the best bid and best ask.")
    spread: float = Field(..., description="The difference between the best ask and best bid.")
    spread_percent: float = Field(..., description="The spread as a percentage of the mid-price.")
    total_bid_volume: float = Field(..., description="Total volume of all bids in the book.")
    total_ask_volume: float = Field(..., description="Total volume of all asks in the book.")
    market_pressure_ratio: float = Field(
        ..., description="Ratio of total bid volume to total ask volume. >1 indicates buy pressure."
    )


# ==============================================================================
# 2. Analysis Calculation Functions
# ==============================================================================


def calculate_trade_stats_from_trades(trades: list[Trade]) -> TradeAnalysis:
    """
    Calculates precise statistics from a list of individual trades. ('full' mode)
    """
    if not trades:
        logger.warning("Trade list is empty, returning zeroed-out stats.")
        return TradeAnalysis(total_volume=0.0, vwap=0.0)

    buy_trades = [t for t in trades if t.side == "buy"]
    sell_trades = [t for t in trades if t.side == "sell"]

    total_volume = sum(t.size for t in trades)
    buy_volume = sum(t.size for t in buy_trades)
    sell_volume = sum(t.size for t in sell_trades)

    weighted_price_sum = sum(t.price * t.size for t in trades)
    vwap = weighted_price_sum / total_volume if total_volume > 0 else 0.0

    return TradeAnalysis(
        total_trades=len(trades),
        buy_trades=len(buy_trades),
        sell_trades=len(sell_trades),
        total_volume=total_volume,
        buy_volume=buy_volume,
        sell_volume=sell_volume,
        vwap=vwap,
    )


def calculate_trade_stats_from_candles(candles: list[Candle]) -> TradeAnalysis:
    """
    Calculates aggregated statistics from candlestick data. ('fast' mode)
    This provides an efficient approximation for VWAP and total volume.
    """
    if not candles:
        logger.warning("Candle list is empty, returning zeroed-out stats.")
        return TradeAnalysis(total_volume=0.0, vwap=0.0)

    total_volume = sum(c.volume for c in candles)

    # Approximate VWAP using (High + Low + Close) / 3 as the typical price for the period
    weighted_price_sum = sum(((c.high + c.low + c.close) / 3) * c.volume for c in candles)
    vwap = weighted_price_sum / total_volume if total_volume > 0 else 0.0

    logger.info("Calculated trade stats from candles (fast mode).")
    return TradeAnalysis(
        total_volume=total_volume,
        vwap=vwap,
        # Other fields are None as they can't be derived from candles
    )


def _safe_get_float(
    series: np.ndarray, index: int = -1, default: float | None = None
) -> float | None:
    """Safely gets a value from a numpy array by index, handling out-of-bounds and NaN."""
    try:
        # Check if the index is valid for the array
        if not (-len(series) <= index < len(series)):
            return default
        val = series[index]
        # np.isnan handles numpy's NaN representation which is float
        return default if np.isnan(val) else float(val)
    except (IndexError, TypeError):
        return default


def calculate_technical_indicators(candles: list[Candle]) -> TechnicalAnalysis:
    """Calculates a comprehensive suite of technical indicators from candlestick data."""
    ma_short, ma_long = 50, 200
    ema_short, ema_medium = 9, 21
    ema_ribbon_periods = [20, 25, 30, 35, 40, 45, 50, 55]
    macd_fast, macd_slow, macd_sign = 12, 26, 9
    adx_period = 14
    ichimoku_t, ichimoku_k, ichimoku_s = 9, 26, 52
    rsi_period, rsi_ob, rsi_os = 14, 70, 30
    stoch_fastk_period, stoch_slowk_period, stoch_slowd_period = 14, 3, 3
    stoch_ob, stoch_os = 80, 20
    williams_period, williams_ob, williams_os = 14, -20, -80
    bb_period, bb_dev = 20, 2
    atr_period, cmf_period = 14, 20

    # Dynamically determine minimum required candles based on the longest lookback period
    lookback_periods = [
        ma_long,
        max(ema_ribbon_periods),
        macd_slow + macd_sign,
        adx_period,
        ichimoku_s,
        rsi_period,
        stoch_fastk_period + stoch_slowk_period + stoch_slowd_period,
        williams_period,
        bb_period,
        atr_period,
        cmf_period,
    ]
    min_required_candles = max(lookback_periods) + 1  # +1 for prev-value checks

    if not candles or len(candles) < min_required_candles:
        logger.warning(
            f"Candle list has insufficient data ({len(candles)} candles, "
            f"need {min_required_candles}), returning empty analysis."
        )
        return TechnicalAnalysis(
            price_change_percent=0.0,
            trend_indicators=TrendAnalysis(
                moving_averages=MovingAverageAnalysis(),
                macd=MACDAnalysis(),
                adx=ADXAnalysis(),
                ichimoku_cloud=IchimokuCloudAnalysis(),
                parabolic_sar=ParabolicSARAnalysis(),
            ),
            momentum_indicators=MomentumAnalysis(),
            volatility_indicators=VolatilityAnalysis(),
            volume_indicators=VolumeAnalysis(),
        )

    df = pd.DataFrame([c.model_dump() for c in candles])
    for col in ["open", "high", "low", "close", "volume"]:
        df[col] = pd.to_numeric(df[col], errors="coerce")
    df.dropna(inplace=True)
    if len(df) < min_required_candles:
        logger.warning(
            f"DataFrame has insufficient data after cleaning ({len(df)} rows), "
            f"returning empty analysis."
        )
        return TechnicalAnalysis(
            price_change_percent=0.0,
            trend_indicators=TrendAnalysis(
                moving_averages=MovingAverageAnalysis(),
                macd=MACDAnalysis(),
                adx=ADXAnalysis(),
                ichimoku_cloud=IchimokuCloudAnalysis(),
                parabolic_sar=ParabolicSARAnalysis(),
            ),
            momentum_indicators=MomentumAnalysis(),
            volatility_indicators=VolatilityAnalysis(),
            volume_indicators=VolumeAnalysis(),
        )

    # Convert to numpy arrays for TA-Lib
    open_ = df["open"].to_numpy(dtype=float)
    high = df["high"].to_numpy(dtype=float)
    low = df["low"].to_numpy(dtype=float)
    close = df["close"].to_numpy(dtype=float)
    volume = df["volume"].to_numpy(dtype=float)

    price_change_percent = ((close[-1] - open_[0]) / open_[0]) * 100

    # --- Trend Indicators ---
    sma_short_series = talib.SMA(close, timeperiod=ma_short)
    sma_long_series = talib.SMA(close, timeperiod=ma_long)
    sma_short_val = _safe_get_float(sma_short_series, -1)
    sma_short_prev = _safe_get_float(sma_short_series, -2)
    sma_long_val = _safe_get_float(sma_long_series, -1)
    sma_long_prev = _safe_get_float(sma_long_series, -2)
    crossover = None
    if all(v is not None for v in [sma_short_val, sma_short_prev, sma_long_val, sma_long_prev]):
        if sma_short_val > sma_long_val and sma_short_prev <= sma_long_prev:
            crossover = "Golden Cross"
        elif sma_short_val < sma_long_val and sma_short_prev >= sma_long_prev:
            crossover = "Death Cross"
    ma_analysis = MovingAverageAnalysis(
        sma_short=sma_short_val,
        sma_long=sma_long_val,
        ema_short=_safe_get_float(talib.EMA(close, timeperiod=ema_short)),
        ema_medium=_safe_get_float(talib.EMA(close, timeperiod=ema_medium)),
        crossover_signal=crossover,
        ema_ribbon={
            f"ema_{p}": _safe_get_float(talib.EMA(close, timeperiod=p)) for p in ema_ribbon_periods
        },
    )

    macd_line_s, signal_line_s, hist_s = talib.MACD(
        close, fastperiod=macd_fast, slowperiod=macd_slow, signalperiod=macd_sign
    )
    hist, hist_prev = _safe_get_float(hist_s, -1), _safe_get_float(hist_s, -2)
    macd_analysis = MACDAnalysis(
        macd_line=_safe_get_float(macd_line_s),
        signal_line=_safe_get_float(signal_line_s),
        histogram=hist,
        momentum=(
            "Strengthening"
            if hist is not None and hist_prev is not None and abs(hist) > abs(hist_prev)
            else "Weakening"
        ),
    )

    adx_val = _safe_get_float(talib.ADX(high, low, close, timeperiod=adx_period))
    adx_analysis = ADXAnalysis(
        adx=adx_val,
        trend_strength="Strong Trend"
        if adx_val is not None and adx_val > 25
        else "Weak or Ranging"
        if adx_val is not None and adx_val < 20
        else "Developing Trend",
    )

    # --- ICHIMOKU CLOUD ---
    tenkan_sen_s = (
        df["high"].rolling(window=ichimoku_t).max() + df["low"].rolling(window=ichimoku_t).min()
    ) / 2
    kijun_sen_s = (
        df["high"].rolling(window=ichimoku_k).max() + df["low"].rolling(window=ichimoku_k).min()
    ) / 2

    # Senkou Span A is (Tenkan + Kijun) / 2, plotted 26 periods ahead.
    senkou_span_a_future = ((tenkan_sen_s + kijun_sen_s) / 2).to_numpy()

    # Senkou Span B is the 52-period high/low midpoint, plotted 26 periods ahead.
    senkou_span_b_future = (
        (df["high"].rolling(window=ichimoku_s).max() + df["low"].rolling(window=ichimoku_s).min())
        / 2
    ).to_numpy()

    # The "current" cloud is what's aligned with the current price,
    # which was projected from 26 periods ago.
    current_senkou_a = _safe_get_float(senkou_span_a_future, index=-ichimoku_k)
    current_senkou_b = _safe_get_float(senkou_span_b_future, index=-ichimoku_k)

    # The Chikou Span (Lagging Span) is the close price from 26 periods ago.
    chikou_span_value = _safe_get_float(close, index=-ichimoku_k)

    price_pos, cloud_color = None, None
    if current_senkou_a is not None and current_senkou_b is not None:
        cloud_top, cloud_bottom = (
            max(current_senkou_a, current_senkou_b),
            min(current_senkou_a, current_senkou_b),
        )
        price = close[-1]
        price_pos = (
            "Above Cloud"
            if price > cloud_top
            else "Below Cloud"
            if price < cloud_bottom
            else "In Cloud"
        )
        cloud_color = "Green" if current_senkou_a > current_senkou_b else "Red"

    # The "future" cloud is what is being projected from the most recent data.
    future_a = _safe_get_float(senkou_span_a_future)
    future_b = _safe_get_float(senkou_span_b_future)
    future_color = (
        "Green" if future_a is not None and future_b is not None and future_a > future_b else "Red"
    )

    ichimoku_analysis = IchimokuCloudAnalysis(
        tenkan_sen=_safe_get_float(tenkan_sen_s.to_numpy()),
        kijun_sen=_safe_get_float(kijun_sen_s.to_numpy()),
        senkou_span_a=current_senkou_a,
        senkou_span_b=current_senkou_b,
        chikou_span=chikou_span_value,
        price_position=price_pos,
        cloud_color=cloud_color,
        future_cloud_color=future_color,
    )

    psar_series = talib.SAR(high, low)
    psar_val, psar_prev = _safe_get_float(psar_series, -1), _safe_get_float(psar_series, -2)
    is_up_now = psar_val is not None and psar_val < low[-1]
    was_up_before = psar_prev is not None and psar_prev < low[-2]
    psar_analysis = ParabolicSARAnalysis(
        psar=psar_val,
        trend_direction="Uptrend" if is_up_now else "Downtrend",
        is_reversal=is_up_now != was_up_before
        if psar_val is not None and psar_prev is not None
        else False,
    )

    trend_analysis = TrendAnalysis(
        moving_averages=ma_analysis,
        macd=macd_analysis,
        adx=adx_analysis,
        ichimoku_cloud=ichimoku_analysis,
        parabolic_sar=psar_analysis,
    )

    # --- Momentum Indicators ---
    rsi_val = _safe_get_float(talib.RSI(close, timeperiod=rsi_period))
    rsi_level = (
        "Overbought"
        if rsi_val and rsi_val > rsi_ob
        else "Oversold"
        if rsi_val and rsi_val < rsi_os
        else "Neutral"
    )

    stoch_k_s, stoch_d_s = talib.STOCH(
        high,
        low,
        close,
        fastk_period=stoch_fastk_period,
        slowk_period=stoch_slowk_period,
        slowd_period=stoch_slowd_period,
    )
    stoch_k_val = _safe_get_float(stoch_k_s)
    stoch_level = (
        "Overbought"
        if stoch_k_val and stoch_k_val > stoch_ob
        else "Oversold"
        if stoch_k_val and stoch_k_val < stoch_os
        else "Neutral"
    )
    williams_r_val = _safe_get_float(talib.WILLR(high, low, close, timeperiod=williams_period))
    williams_r_level = (
        "Overbought"
        if williams_r_val and williams_r_val > williams_ob
        else "Oversold"
        if williams_r_val and williams_r_val < williams_os
        else "Neutral"
    )

    momentum_analysis = MomentumAnalysis(
        rsi=rsi_val,
        rsi_level=rsi_level,
        stochastic_k=stoch_k_val,
        stochastic_d=_safe_get_float(stoch_d_s),
        stochastic_level=stoch_level,
        williams_r=williams_r_val,
        williams_r_level=williams_r_level,
    )

    # --- Volatility Indicators ---
    bb_upper, bb_middle, bb_lower = talib.BBANDS(
        close, timeperiod=bb_period, nbdevup=bb_dev, nbdevdn=bb_dev
    )
    bb_upper_val = _safe_get_float(bb_upper)
    bb_middle_val = _safe_get_float(bb_middle)
    bb_lower_val = _safe_get_float(bb_lower)
    bb_bw, bb_p = None, None
    if all(v is not None for v in [bb_upper_val, bb_middle_val, bb_lower_val]):
        if bb_middle_val > 0:
            bb_bw = (bb_upper_val - bb_lower_val) / bb_middle_val
        band_range = bb_upper_val - bb_lower_val
        if band_range > 0:
            bb_p = (close[-1] - bb_lower_val) / band_range

    volatility_analysis = VolatilityAnalysis(
        atr=_safe_get_float(talib.ATR(high, low, close, timeperiod=atr_period)),
        bollinger_hband=bb_upper_val,
        bollinger_lband=bb_lower_val,
        bollinger_mavg=bb_middle_val,
        bollinger_bandwidth=bb_bw,
        bollinger_percent_b=bb_p,
    )

    # --- Volume Indicators ---
    mfm = np.where((high - low) > 0, ((close - low) - (high - close)) / (high - low), 0)
    mfv = mfm * volume
    cmf_s = talib.SUM(mfv, cmf_period) / talib.SUM(volume, cmf_period)

    volume_analysis = VolumeAnalysis(
        on_balance_volume=_safe_get_float(talib.OBV(close, volume)),
        chaikin_money_flow=_safe_get_float(cmf_s),
    )

    return TechnicalAnalysis(
        price_change_percent=price_change_percent,
        trend_indicators=trend_analysis,
        momentum_indicators=momentum_analysis,
        volatility_indicators=volatility_analysis,
        volume_indicators=volume_analysis,
    )


def calculate_order_book_stats(order_book: OrderBook) -> OrderBookAnalysis:
    """Calculates key metrics from the order book."""
    if not order_book.bids or not order_book.asks:
        logger.warning("Order book is missing bids or asks, cannot perform analysis.")
        return OrderBookAnalysis(
            best_bid=0.0,
            best_ask=0.0,
            mid_price=0.0,
            spread=0.0,
            spread_percent=0.0,
            total_bid_volume=0.0,
            total_ask_volume=0.0,
            market_pressure_ratio=0.0,
        )

    best_bid = order_book.bids[0].price
    best_ask = order_book.asks[0].price

    mid_price = (best_ask + best_bid) / 2
    spread = best_ask - best_bid
    spread_percent = (spread / mid_price) * 100 if mid_price > 0 else 0.0

    total_bid_volume = sum(level.size for level in order_book.bids)
    total_ask_volume = sum(level.size for level in order_book.asks)

    market_pressure_ratio = (
        total_bid_volume / total_ask_volume if total_ask_volume > 0 else float("inf")
    )

    return OrderBookAnalysis(
        best_bid=best_bid,
        best_ask=best_ask,
        mid_price=mid_price,
        spread=spread,
        spread_percent=spread_percent,
        total_bid_volume=total_bid_volume,
        total_ask_volume=total_ask_volume,
        market_pressure_ratio=market_pressure_ratio,
    )


# ==============================================================================
# 3. Main Analysis Runner
# ==============================================================================


def run_analysis(
    symbol: str,
    trades: list[Trade],
    candles: list[Candle],
    mode: Literal["fast", "full"] = "fast",
) -> AnalysisResult:
    """Runs all analysis functions and returns a composite result."""
    logger.info(f"Running analysis for {symbol} in '{mode}' mode...")

    if mode == "full":
        trade_stats = calculate_trade_stats_from_trades(trades)
    else:  # 'fast' mode
        trade_stats = calculate_trade_stats_from_candles(candles)

    technical_analysis = calculate_technical_indicators(candles)
    return AnalysisResult(
        symbol=symbol,
        trade_stats=trade_stats,
        technical_analysis=technical_analysis,
    )
