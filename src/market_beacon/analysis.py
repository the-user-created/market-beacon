# src/market_beacon/analysis.py

from typing import Literal

import pandas as pd
import ta
from loguru import logger
from pydantic import BaseModel, Field

from .api.models import Candle, Trade

# ==============================================================================
# 1. Pydantic Models for Analysis Results
# ==============================================================================


class TradeAnalysis(BaseModel):
    """Pydantic model for holding trade analysis results."""

    total_trades: int
    buy_trades: int
    sell_trades: int
    total_volume: float = Field(..., description="Total volume of all trades")
    buy_volume: float = Field(..., description="Volume of buy-side trades")
    sell_volume: float = Field(..., description="Volume of sell-side trades")
    vwap: float = Field(..., description="Volume-Weighted Average Price")


class MovingAverageAnalysis(BaseModel):
    """Analysis of various moving averages and their signals."""

    sma_short: float | None = Field(None, description="Simple Moving Average (e.g., 50-period)")
    sma_long: float | None = Field(None, description="Simple Moving Average (e.g., 200-period)")
    ema_short: float | None = Field(None, description="Exponential Moving Average (e.g., 9-period)")
    ema_medium: float | None = Field(
        None, description="Exponential Moving Average (e.g., 21-period)"
    )
    crossover_signal: Literal["Golden Cross", "Death Cross"] | None = Field(
        None, description="Signal generated by short-term MA crossing long-term MA."
    )
    ema_ribbon: dict[str, float | None] = Field(
        default_factory=dict, description="A series of EMAs to form a trend ribbon."
    )


class MACDAnalysis(BaseModel):
    """Analysis of the Moving Average Convergence Divergence."""

    macd_line: float | None = Field(None, description="The MACD line value.")
    signal_line: float | None = Field(None, description="The signal line value.")
    histogram: float | None = Field(None, description="The MACD histogram value (MACD - Signal).")
    momentum: Literal["Strengthening", "Weakening"] | None = Field(
        None, description="Momentum based on the histogram's recent movement."
    )


class ADXAnalysis(BaseModel):
    """Analysis of the Average Directional Index."""

    adx: float | None = Field(None, description="Average Directional Index value.")
    trend_strength: str | None = Field(
        None, description="Interpretation of the ADX value (e.g., 'Strong Trend')."
    )


class IchimokuCloudAnalysis(BaseModel):
    """Analysis of the Ichimoku Cloud indicator."""

    tenkan_sen: float | None = Field(None, description="Conversion Line (Tenkan-sen)")
    kijun_sen: float | None = Field(None, description="Base Line (Kijun-sen)")
    senkou_span_a: float | None = Field(
        None, description="Leading Span A aligned with the current price."
    )
    senkou_span_b: float | None = Field(
        None, description="Leading Span B aligned with the current price."
    )
    chikou_span: float | None = Field(
        None, description="Lagging Span value (close price from 26 periods ago)."
    )
    price_position: Literal["Above Cloud", "Below Cloud", "In Cloud"] | None = Field(
        None, description="Position of the current price relative to the Kumo cloud."
    )
    cloud_color: Literal["Green", "Red"] | None = Field(
        None, description="Color of the current Kumo cloud."
    )
    future_cloud_color: Literal["Green", "Red"] | None = Field(
        None, description="Color of the future Kumo cloud, indicating a potential 'Kumo Twist'."
    )


class ParabolicSARAnalysis(BaseModel):
    """Analysis of the Parabolic Stop and Reverse."""

    psar: float | None = Field(None, description="Parabolic Stop and Reverse value.")
    trend_direction: Literal["Uptrend", "Downtrend"] | None = Field(
        None, description="Indicated trend direction."
    )
    is_reversal: bool = Field(
        False, description="True if a reversal occurred on the latest candle."
    )


class MomentumAnalysis(BaseModel):
    """Analysis of key momentum oscillators."""

    rsi: float | None = Field(None, description="Relative Strength Index (RSI) value.")
    rsi_level: Literal["Overbought", "Oversold", "Neutral"] | None = Field(
        None, description="Interpretation of the RSI level."
    )
    stochastic_k: float | None = Field(None, description="Stochastic Oscillator %K value.")
    stochastic_d: float | None = Field(None, description="Stochastic Oscillator %D (signal) value.")
    stochastic_level: Literal["Overbought", "Oversold", "Neutral"] | None = Field(
        None, description="Interpretation of the Stochastic level."
    )
    williams_r: float | None = Field(None, description="Williams %R value.")
    williams_r_level: Literal["Overbought", "Oversold", "Neutral"] | None = Field(
        None, description="Interpretation of the Williams %R level."
    )


class VolatilityAnalysis(BaseModel):
    """Analysis of market volatility."""

    atr: float | None = Field(None, description="Average True Range (14-period).")
    bollinger_hband: float | None = Field(None, description="Bollinger Bands Upper Band.")
    bollinger_lband: float | None = Field(None, description="Bollinger Bands Lower Band.")
    bollinger_mavg: float | None = Field(None, description="Bollinger Bands Middle Average.")
    bollinger_bandwidth: float | None = Field(None, description="Width of the Bollinger Bands.")
    bollinger_percent_b: float | None = Field(
        None, description="Price position relative to bands, as a percentage."
    )


class VolumeAnalysis(BaseModel):
    """Analysis of volume-based indicators."""

    on_balance_volume: float | None = Field(None, description="On-Balance Volume (OBV).")
    chaikin_money_flow: float | None = Field(None, description="Chaikin Money Flow (CMF).")


class TrendAnalysis(BaseModel):
    """Container for all trend-related indicators."""

    moving_averages: MovingAverageAnalysis
    macd: MACDAnalysis
    adx: ADXAnalysis
    ichimoku_cloud: IchimokuCloudAnalysis
    parabolic_sar: ParabolicSARAnalysis


class TechnicalAnalysis(BaseModel):
    """A composite model for all technical analysis indicators from candlestick data."""

    price_change_percent: float = Field(
        ..., description="Percentage change from first open to last close"
    )
    trend_indicators: TrendAnalysis = Field(
        ..., description="Trend-following indicators like MAs, MACD, etc."
    )
    momentum_indicators: MomentumAnalysis = Field(
        ..., description="Oscillators like RSI and Stochastics."
    )
    volatility_indicators: VolatilityAnalysis = Field(
        ..., description="Indicators measuring market volatility like ATR and Bollinger Bands."
    )
    volume_indicators: VolumeAnalysis = Field(
        ..., description="Indicators based on trade volume like OBV and CMF."
    )


class AnalysisResult(BaseModel):
    """A composite model for all analysis results."""

    symbol: str
    trade_stats: TradeAnalysis
    technical_analysis: TechnicalAnalysis


# ==============================================================================
# 2. Analysis Calculation Functions
# ==============================================================================


def calculate_trade_stats(trades: list[Trade]) -> TradeAnalysis:
    """Calculates statistics from a list of recent trades."""
    if not trades:
        logger.warning("Trade list is empty, returning zeroed-out stats.")
        return TradeAnalysis(
            total_trades=0,
            buy_trades=0,
            sell_trades=0,
            total_volume=0.0,
            buy_volume=0.0,
            sell_volume=0.0,
            vwap=0.0,
        )
    buy_trades = [t for t in trades if t.side == "buy"]
    sell_trades = [t for t in trades if t.side == "sell"]
    total_volume = sum(t.size for t in trades)
    buy_volume = sum(t.size for t in buy_trades)
    sell_volume = sum(t.size for t in sell_trades)
    weighted_price_sum = sum(t.price * t.size for t in trades)
    vwap = weighted_price_sum / total_volume if total_volume > 0 else 0.0
    return TradeAnalysis(
        total_trades=len(trades),
        buy_trades=len(buy_trades),
        sell_trades=len(sell_trades),
        total_volume=total_volume,
        buy_volume=buy_volume,
        sell_volume=sell_volume,
        vwap=vwap,
    )


def _safe_get(series: pd.Series, index: int = -1, default: float | None = None) -> float | None:
    """Safely gets a value from a pandas Series by index, handling out-of-bounds and NaN."""
    try:
        # Adjusted to handle both positive and negative indices safely
        if not (-len(series) <= index < len(series)):
            return default
        val = series.iloc[index]
        return default if pd.isna(val) else float(val)
    except (IndexError, TypeError):
        return default


def calculate_technical_indicators(candles: list[Candle]) -> TechnicalAnalysis:
    """Calculates a comprehensive suite of technical indicators from candlestick data."""
    # Define periods
    ma_short, ma_long = 50, 200
    ema_short, ema_medium = 9, 21
    ema_ribbon_periods = [20, 25, 30, 35, 40, 45, 50]
    macd_fast, macd_slow, macd_sign = 12, 26, 9
    adx_period, ichimoku_t, ichimoku_k, ichimoku_s = 14, 9, 26, 52
    rsi_period, rsi_ob, rsi_os = 14, 70, 30
    stoch_period, stoch_ob, stoch_os = 14, 80, 20
    williams_period, williams_ob, williams_os = 14, -20, -80
    bb_period, bb_dev = 20, 2
    atr_period, cmf_period = 14, 20

    min_required_candles = ma_long + ichimoku_s
    if not candles or len(candles) < min_required_candles:
        logger.warning(
            f"Candle list has insufficient data ({len(candles)} candles, "
            f"need {min_required_candles}), returning empty analysis."
        )
        return TechnicalAnalysis(
            price_change_percent=0.0,
            trend_indicators=TrendAnalysis(
                moving_averages=MovingAverageAnalysis(),
                macd=MACDAnalysis(),
                adx=ADXAnalysis(),
                ichimoku_cloud=IchimokuCloudAnalysis(),
                parabolic_sar=ParabolicSARAnalysis(),
            ),
            momentum_indicators=MomentumAnalysis(),
            volatility_indicators=VolatilityAnalysis(),
            volume_indicators=VolumeAnalysis(),
        )

    df = pd.DataFrame([c.model_dump() for c in candles])
    for col in ["open", "high", "low", "close", "volume"]:
        df[col] = pd.to_numeric(df[col], errors="coerce")
    df.dropna(inplace=True)
    if df.empty or len(df) < min_required_candles:
        logger.warning(
            f"DataFrame has insufficient data after cleaning ({len(df)} rows), "
            f"returning empty analysis."
        )
        return TechnicalAnalysis(
            price_change_percent=0.0,
            trend_indicators=TrendAnalysis(
                moving_averages=MovingAverageAnalysis(),
                macd=MACDAnalysis(),
                adx=ADXAnalysis(),
                ichimoku_cloud=IchimokuCloudAnalysis(),
                parabolic_sar=ParabolicSARAnalysis(),
            ),
            momentum_indicators=MomentumAnalysis(),
            volatility_indicators=VolatilityAnalysis(),
            volume_indicators=VolumeAnalysis(),
        )

    price_change_percent = ((df["close"].iloc[-1] - df["open"].iloc[0]) / df["open"].iloc[0]) * 100

    # --- Trend Indicators ---
    sma_short_series = ta.trend.sma_indicator(df["close"], window=ma_short)
    sma_long_series = ta.trend.sma_indicator(df["close"], window=ma_long)
    sma_short_val, sma_short_prev = _safe_get(sma_short_series, -1), _safe_get(sma_short_series, -2)
    sma_long_val, sma_long_prev = _safe_get(sma_long_series, -1), _safe_get(sma_long_series, -2)
    crossover = None
    if all(v is not None for v in [sma_short_val, sma_short_prev, sma_long_val, sma_long_prev]):
        if sma_short_val > sma_long_val and sma_short_prev <= sma_long_prev:
            crossover = "Golden Cross"
        elif sma_short_val < sma_long_val and sma_short_prev >= sma_long_prev:
            crossover = "Death Cross"
    ma_analysis = MovingAverageAnalysis(
        sma_short=sma_short_val,
        sma_long=sma_long_val,
        ema_short=_safe_get(ta.trend.ema_indicator(df["close"], ema_short)),
        ema_medium=_safe_get(ta.trend.ema_indicator(df["close"], ema_medium)),
        crossover_signal=crossover,
        ema_ribbon={
            f"ema_{p}": _safe_get(ta.trend.ema_indicator(df["close"], p))
            for p in ema_ribbon_periods
        },
    )

    macd_ind = ta.trend.MACD(df["close"], macd_slow, macd_fast, macd_sign)
    hist, hist_prev = _safe_get(macd_ind.macd_diff(), -1), _safe_get(macd_ind.macd_diff(), -2)
    macd_analysis = MACDAnalysis(
        macd_line=_safe_get(macd_ind.macd()),
        signal_line=_safe_get(macd_ind.macd_signal()),
        histogram=hist,
        momentum="Strengthening"
        if hist and hist_prev and abs(hist) > abs(hist_prev)
        else "Weakening",
    )

    adx_val = _safe_get(ta.trend.adx(df["high"], df["low"], df["close"], adx_period))
    adx_analysis = ADXAnalysis(
        adx=adx_val,
        trend_strength="Strong Trend"
        if adx_val and adx_val > 25
        else "Weak or Ranging"
        if adx_val and adx_val < 20
        else "Developing Trend",
    )

    # --- ICHIMOKU CLOUD ---
    ichi_ind = ta.trend.IchimokuIndicator(
        df["high"], df["low"], window1=ichimoku_t, window2=ichimoku_k, window3=ichimoku_s
    )
    span_a_series = ichi_ind.ichimoku_a()
    span_b_series = ichi_ind.ichimoku_b()
    current_senkou_a = _safe_get(span_a_series, index=-1 - ichimoku_k)
    current_senkou_b = _safe_get(span_b_series, index=-1 - ichimoku_k)
    chikou_span_value = _safe_get(df["close"], index=-1 - ichimoku_k)
    price_pos, cloud_color = None, None
    if current_senkou_a is not None and current_senkou_b is not None:
        cloud_top, cloud_bottom = (
            max(current_senkou_a, current_senkou_b),
            min(current_senkou_a, current_senkou_b),
        )
        price = df["close"].iloc[-1]
        price_pos = (
            "Above Cloud"
            if price > cloud_top
            else "Below Cloud"
            if price < cloud_bottom
            else "In Cloud"
        )
        cloud_color = "Green" if current_senkou_a > current_senkou_b else "Red"
    future_a = _safe_get(span_a_series, index=-1)
    future_b = _safe_get(span_b_series, index=-1)
    future_color = (
        "Green" if future_a is not None and future_b is not None and future_a > future_b else "Red"
    )

    ichimoku_analysis = IchimokuCloudAnalysis(
        tenkan_sen=_safe_get(ichi_ind.ichimoku_conversion_line()),
        kijun_sen=_safe_get(ichi_ind.ichimoku_base_line()),
        senkou_span_a=current_senkou_a,
        senkou_span_b=current_senkou_b,
        chikou_span=chikou_span_value,
        price_position=price_pos,
        cloud_color=cloud_color,
        future_cloud_color=future_color,
    )

    psar_series = ta.trend.PSARIndicator(df["high"], df["low"], df["close"]).psar()
    psar_val, psar_prev = _safe_get(psar_series, -1), _safe_get(psar_series, -2)
    is_up_now = psar_val is not None and psar_val < df["low"].iloc[-1]
    was_up_before = psar_prev is not None and psar_prev < df["low"].iloc[-2]
    psar_analysis = ParabolicSARAnalysis(
        psar=psar_val,
        trend_direction="Uptrend" if is_up_now else "Downtrend",
        is_reversal=is_up_now != was_up_before if psar_val and psar_prev else False,
    )

    trend_analysis = TrendAnalysis(
        moving_averages=ma_analysis,
        macd=macd_analysis,
        adx=adx_analysis,
        ichimoku_cloud=ichimoku_analysis,
        parabolic_sar=psar_analysis,
    )

    # --- Momentum, Volatility, and Volume Indicators ---
    rsi_val = _safe_get(ta.momentum.rsi(df["close"], rsi_period))
    rsi_level = (
        "Overbought"
        if rsi_val and rsi_val > rsi_ob
        else "Oversold"
        if rsi_val and rsi_val < rsi_os
        else "Neutral"
    )
    stoch_k = _safe_get(ta.momentum.stoch(df["high"], df["low"], df["close"], stoch_period))
    stoch_level = (
        "Overbought"
        if stoch_k and stoch_k > stoch_ob
        else "Oversold"
        if stoch_k and stoch_k < stoch_os
        else "Neutral"
    )
    williams_r_val = _safe_get(
        ta.momentum.williams_r(df["high"], df["low"], df["close"], williams_period)
    )
    williams_r_level = (
        "Overbought"
        if williams_r_val and williams_r_val > williams_ob
        else "Oversold"
        if williams_r_val and williams_r_val < williams_os
        else "Neutral"
    )

    momentum_analysis = MomentumAnalysis(
        rsi=rsi_val,
        rsi_level=rsi_level,
        stochastic_k=stoch_k,
        stochastic_d=_safe_get(
            ta.momentum.stoch_signal(df["high"], df["low"], df["close"], stoch_period)
        ),
        stochastic_level=stoch_level,
        williams_r=williams_r_val,
        williams_r_level=williams_r_level,
    )

    bb_ind = ta.volatility.BollingerBands(df["close"], bb_period, bb_dev)
    volatility_analysis = VolatilityAnalysis(
        atr=_safe_get(
            ta.volatility.average_true_range(df["high"], df["low"], df["close"], atr_period)
        ),
        bollinger_hband=_safe_get(bb_ind.bollinger_hband()),
        bollinger_lband=_safe_get(bb_ind.bollinger_lband()),
        bollinger_mavg=_safe_get(bb_ind.bollinger_mavg()),
        bollinger_bandwidth=_safe_get(bb_ind.bollinger_wband()),
        bollinger_percent_b=_safe_get(bb_ind.bollinger_pband()),
    )

    volume_analysis = VolumeAnalysis(
        on_balance_volume=_safe_get(ta.volume.on_balance_volume(df["close"], df["volume"])),
        chaikin_money_flow=_safe_get(
            ta.volume.chaikin_money_flow(
                df["high"], df["low"], df["close"], df["volume"], cmf_period
            )
        ),
    )

    return TechnicalAnalysis(
        price_change_percent=price_change_percent,
        trend_indicators=trend_analysis,
        momentum_indicators=momentum_analysis,
        volatility_indicators=volatility_analysis,
        volume_indicators=volume_analysis,
    )


# ==============================================================================
# 3. Main Analysis Runner
# ==============================================================================


def run_analysis(symbol: str, trades: list[Trade], candles: list[Candle]) -> AnalysisResult:
    """Runs all analysis functions and returns a composite result."""
    logger.info(f"Running analysis for {symbol}...")
    trade_stats = calculate_trade_stats(trades)
    technical_analysis = calculate_technical_indicators(candles)
    return AnalysisResult(
        symbol=symbol,
        trade_stats=trade_stats,
        technical_analysis=technical_analysis,
    )
